-- --- 关卡小地图
-- --- Generated by EmmyLua(https://github.com/EmmyLua)
-- --- Created by aaa.
-- --- DateTime: 2019/9/25 14:19
-- --- 这个该死的地图资源在界面的关闭时就会清除资源，所有延迟的操作（动画，定时器）注意组件可能已经被注销但是还在使用
-- --- 对于引用的物体在注销物体时注销引用
-- ---
-- require("Base/Stack")
-- require("Modules/Map/Logic/TileMapController")
-- require("Modules/Map/Logic/TileMapView")
-- require("Modules/Map/Config/MapConfig")
-- require("Modules/Map/View/MapPointView")
-- local mapIconConfig = ConfigManager.GetConfig(ConfigName.MainMapIconConfig)
-- local iconAction = require("Modules/Fight/View/FightMapIconShowView")

-- local this = {}
-- local mapCtrl = "MapCtrl"
-- this.bLeaderIsIdle = false

-- local callList = Stack.New()
-- local funcCanPass = function(data) return data.val <= 1 end
-- local curDir
-- -- 允许出现的事件点的图标数量
-- local iconNum = 3
-- -- 被选中去死的事件点
-- local selectPointPos = 0
-- local isPanelClose = false
-- local mapIdList = {
--     [1] = 5002,
--     [2] = 5003,
--     [3] = 5005,
--     [4] = 4002,
--     [5] = 5004,
-- }
-- local InitCamPos = {
--     [4002] = {pos = Vector3.New(27.5, -27.5, -50)},
--     [5005] = {pos = Vector3.New(20, -15, -50)},
--     [5002] = {pos = Vector3.New(27.5, -27.5, -50)},
--     [5003] = {pos = Vector3.New(27.5, -18, -50)},
--     [5004] = {pos = Vector3.New(27.5, -18, -50)},
-- }
-- -- 临时可生成怪的区域
-- local monsterArea = {
--     [5005] = {
--         x_pos = {min = 10, max = 28},
--         y_pos = {min = 8, max = 14},
--     },
--     [4002] = {
--         x_pos = {min = 10, max = 20},
--         y_pos = {min = 10, max = 15},
--     },
--     [5002] = {
--         x_pos = {min = 9, max = 28},
--         y_pos = {min = 8, max = 16},
--     },
--     [5003] = {
--         x_pos = {min = 9, max = 27},
--         y_pos = {min = 8, max = 14},
--     },
--     [5004] = {
--         x_pos = {min = 9, max = 27},
--         y_pos = {min = 8, max = 14},
--     },
-- }
-- local startUV = {
--     [5005] = {u = 11, v = 8},
--     [4002] = {u = 15, v = 15},
--     [5002] = {u = 15, v = 15},
--     [5003] = {u = 15, v = 10},
--     [5004] = {u = 15, v = 10},
-- }
-- -- 地图图标的上限值
-- local maxIcon = 9
-- -- NPC
-- local roleRootPath = "UI_effect_DiTu_huoguang"
-- local npc1 = "live2d_npc_map"
-- local npc2 = "live2d_npc_map_nv"
-- local npc, scale
-- local testAnims = {
--     "jingya",
--     "lauch",
--     "touch"
-- }


-- -- 当前关卡地图编号
-- local m_curMapId = 1011

-- local m_orginLayer


-- -- 角色停止行走时的朝向, 上 下 左 右，1 2 3 4
-- local m_faceDir = 0
-- -- 设置角色行走方向
-- local WALK_DIR = {
--     RIGHT = {animation = "move2", y = 0},
--     LEFT = {animation = "move2", y = 180},
--     UP = {animation = "move3", y = 0},
--     DOWN = {animation = "move", y = 0},
-- }
-- -- 宝箱特效的位置
-- local boxEffectPos = {
--     [1] = Vector3.New(44, 140, 0),
--     [2] = Vector3.New(35, 188, 0),
--     [3] = Vector3.New(169, 168, 0),
-- }

-- local m_roleFaceDir = Vector2.New(-1, 0)

-- local SkeletonGraphic
-- ------------- 关卡地图的相关设置 -----------------
-- -- 地图的显示初始位置


-- -- 关卡地图
-- local mapRes = {
--     [1] = "r_guanka_bg1",
--     [2] = "r_guanka_bg2"
-- }
-- ------------------------------------------------
-- local effectPath = "eff_UI_loot_line" --m5
-- local m_parent

-- -- 缓存2个buff加成信息
-- this.buffTipList = {}

-- -- 撞击事件结束后的回调
-- local hitCallBack = function ()
--     this.targetTimer = nil
--     this.BattleEnd()  -- 战斗结束
--     SkeletonGraphic.AnimationState:SetAnimation(0, "idle", true)
--     this.targetTimer = Timer.New(function ()   -- 延迟生成下一个小怪
--         if not isPanelClose then
--             this.LoadPointIcon(math.random(1, maxIcon), false)
--             this.SetRoleHitTarget()
--         end
--     end, 0.5)
--     this.targetTimer:Start()
-- end

-- function this:InitComponent(root, parent)
--     m_orginLayer = 0
--     m_parent = parent
--     this.buffTipList = {}
--     -- 地图点击拖动
--     this.dragCtrl = Util.GetGameObject(root, "Bg/Ctrl")
--     this.effectRoot = Util.GetGameObject(root, "effectRoot")
--     this.hitEffect = Util.GetGameObject(this.effectRoot, "UI_Map_XunBaoEffect_hit")
--     this.buffTip = Util.GetGameObject(root, "effectRoot/money")
--     -- 箱子
--     this.boxEffect = Util.GetGameObject(root, "boxRoot/UI_effect_GuaJi_Box_BaoDian")

--     -- buff飘字
--     for i = 1, 3 do
--         if not this.buffTipList[i] then
--             this.buffTipList[i] = newObjToParent(this.buffTip, this.effectRoot)
--             this.buffTipList[i].transform.localScale = Vector3.New(1.2, 1.2, 1.2)
--             this.buffTipList[i]:SetActive(false)
--         end
--     end

-- end

-- function this:AddListener()
--     Game.GlobalEvent:AddEvent(GameEvent.Adventure.OnRefeshBoxRewardShow, this.HideEffect)

-- end

-- function this:RemoveListener()
--     Game.GlobalEvent:RemoveEvent(GameEvent.Adventure.OnRefeshBoxRewardShow, this.HideEffect)

-- end


-- function this:Init()
--     isPanelClose = false
--     -- 初始化加载地图块数据
--     this:LoadMapData()
--     -- 加载一个小人
--     this.LoadRole(startUV[m_curMapId].u, startUV[m_curMapId].v)
--     -- 初始化两个地图标志
--     this.LoadMapIcon()

-- end

-- function this:LoadMapData()
--     UIManager.camera.clearFlags = CameraClearFlags.Depth
--     -- 所有物体的根节点

--     this.mapRoot = poolManager:LoadAsset(mapCtrl, PoolManager.AssetType.GameObject)
--     this.mapRoot.name = mapCtrl
--     this.mapRoot.transform:SetParent(UIManager.uiRoot.transform.parent)
--     this.mapRoot.transform.position = Vector3.New(0, 0, -100)

--     TileMapView.fogSize = 2
--     local curChapter = FightPointPassManager.GetCurChapterIndex()
--     local index = 1
--     index = math.floor((curChapter - 1) % 5 + 1)


--     m_curMapId =  mapIdList[index]

--     TileMapView.AwakeInit(this.mapRoot, m_curMapId, nil, Vector2.New(180, 180))
--     TileMapView.isShowFog = false


--     TileMapController.IsShieldDrag = function()
--         --当栈中有逻辑，则拖动可以打断镜头跟随

--         return false
--     end
--     TileMapController.OnClickTile = this.OnClickTile
--     TileMapController.Init(this.mapRoot, this.dragCtrl)

--     TileMapView.Init()

--     --TileMapView.SetSpriteBG(mapRes[index])

--     -- 设置镜头的尺寸
--     TileMapView.SetMapScale(Screen.height / 1920)

--     -- 设置相机初始化位置
--     local camInitPos = InitCamPos[m_curMapId].pos
--     TileMapView.SetCameraPos(camInitPos)

--     callList:Clear()
--     --  设置不点击
--     this.dragCtrl:SetActive(false)

--     -- 挂机特效
--     this.moneyEffect = poolManager:LoadAsset(effectPath, PoolManager.AssetType.GameObject)
--     this.moneyEffect.transform:SetParent(this.effectRoot.transform)
--     this.moneyEffect.transform.localScale = Vector3.one
--     this.moneyEffect.transform.localPosition = Vector3.New(0, 0, 0)
--     this.moneyEffect:SetActive(false)


--     Util.AddParticleSortLayer(this.moneyEffect, m_parent.sortingOrder - m_orginLayer)
--     Util.AddParticleSortLayer(this.hitEffect, m_parent.sortingOrder - m_orginLayer)
--     Util.AddParticleSortLayer(this.boxEffect, m_parent.sortingOrder - m_orginLayer)
--     m_orginLayer = m_parent.sortingOrder
--     this:OnSortingOrderChange(m_parent.sortingOrder)
--     this.boxEffect:SetActive(false)
-- end
-- function this:OnSortingOrderChange(orginLayer)
--     if this.moneyEffect then
--         Util.AddParticleSortLayer(this.moneyEffect, orginLayer - m_orginLayer)
--         Util.AddParticleSortLayer(this.hitEffect, orginLayer - m_orginLayer)
--         Util.AddParticleSortLayer(this.boxEffect, orginLayer -m_orginLayer)
--         m_orginLayer = orginLayer
--         iconAction:OnSortingOrderChange(m_parent.sortingOrder)
--         Util.AddParticleSortLayer(this.moneyEffect, m_parent.sortingOrder - m_orginLayer)
--         Util.AddParticleSortLayer(this.hitEffect, m_parent.sortingOrder - m_orginLayer)
--         Util.AddParticleSortLayer(this.boxEffect, m_parent.sortingOrder - m_orginLayer)
--         m_orginLayer = m_parent.sortingOrder
--     end
-- end
-- function this.GetCurLayer()
--     return m_orginLayer
-- end

-- function this.LoadMapIcon()
--     this.iconList = {}
--     FightPointPassManager.isBeginFight = false
--     for i = 1, iconNum do
--         this.LoadPointIcon(math.random(1, maxIcon), false)
--     end

--     PlayUIAnim(this.role, function ()
--         if not isPanelClose then
--             -- 初始化延迟一秒启动寻路
--             this.startTimer = nil
--             this.startTimer = Timer.New(function ()
--                 this.SetRoleHitTarget()
--             end, 1)
--             this.startTimer:Start()
--         end
--     end)
-- end


-- function this.LoadRole(u, v)
--     this.role = poolManager:LoadAsset(roleRootPath, PoolManager.AssetType.GameObject)
--     this.role:SetActive(false)
--     Util.GetGameObject(this.role, "root/ui"):GetComponent("Canvas").worldCamera = TileMapView.GetCamera()
--     local v3 = TileMapView.GetLiveTilePos(u, v)
--     this.role.transform:SetParent(this.mapRoot.transform)
--     this.role.transform.localPosition = Vector3(v3.x, v3.y, v3.z - 10)
--     this.role.transform.localScale = Vector3.one * 1.5

--     npc = NameManager.roleSex == ROLE_SEX.BOY and npc1 or npc2
--     scale = NameManager.roleSex == ROLE_SEX.BOY and 1 or 0.5

--     -- this.NpcGO = poolManager:LoadLive(npc, Util.GetTransform(this.role, "root/ui/roleRoot"), Vector3.one * scale, Vector3.zero)
--     -- this.NpcGO = Util.GetGameObject(this.role, "root/ui/roleRoot/npc")
--     -- this.NpcGO.name = "npc"
--     this.roleCurPos = TileMapView.GetMapData():GetMapData(u, v)

--     this.roleRoot = Util.GetGameObject(this.role, "root/ui/roleRoot")
--     -- SkeletonGraphic = Util.GetGameObject(this.role, "root/ui/roleRoot/npc"):GetComponent("SkeletonGraphic")

--     -- SkeletonGraphic.AnimationState:SetAnimation(0, "lauch", false)
--     -- SkeletonGraphic.transform.localEulerAngles = Vector3.zero
--     this.bLeaderIsIdle = true

--     this.battleEffect = Util.GetGameObject(this.role, "root/ui/quickBattleEffect")

--     -- 临时代码
--     this.dialogueRoot = Util.GetGameObject(this.role, "root/ui/Dialogue")
--     this.context = Util.GetGameObject(this.role, "root/ui/Dialogue/Text"):GetComponent("Text")

--     -- buff特效
--     this.buffEffectRoot = Util.GetGameObject(this.role, "root/ui/roleRoot/effectRoot")
--     this.hitEffect:SetActive(false)
--     Util.SetParticleScale(this.buffEffectRoot, 2)
--     -- 攻击buff
--     this.buffAttack = Util.GetGameObject(this.buffEffectRoot, "r_MapEffect_NewEvent_011")
--     -- 防御buff
--     this.buffDefend = Util.GetGameObject(this.buffEffectRoot, "r_MapEffect_NewEvent_012")

--     -- 隐藏一堆东西
--     this.HideSomeTrash()
--     this.SetBattleState(false)
--     curDir = nil

--     this.role:SetActive(true)


--     --- 注册组件
--     iconAction.InitRegisterComponent(this)

-- end

-- function this.HideSomeTrash()
--     Util.GetGameObject(this.role, "root/ui/arrow"):SetActive(false)
--     Util.GetGameObject(this.role, "root/ui/pos"):SetActive(false)
--     Util.GetGameObject(this.role, "root/ui/blood"):SetActive(false)
--     Util.GetGameObject(this.role, "root/ui/optionCancelBtn"):SetActive(false)
--     Util.GetGameObject(this.role, "root/ui/roleOption"):SetActive(false)
--     this.buffEffectRoot:SetActive(false)

--     for i = 1, 3 do
--         this.buffTipList[i]:SetActive(false)
--     end

-- end


-- ---==============  Point Icon Handle =================================
-- --- 生成一个图标, 传入校验权重值rand, 是否使用动画
-- function this.LoadPointIcon(rand, useAnim)
--     -- 随机一个坐标
--     local area = monsterArea[m_curMapId]
--     local u = math.random(area.x_pos.min, area.x_pos.max)
--     local v = math.random(area.y_pos.min, area.y_pos.max)
--     local pos = Map_UV2Pos(u, v)

--     local mapPointId = rand

--     -- 随机出来的位置已经有图标，则再次随机
--     if this.iconList[pos] or pos == 1285 or this.IsHaveBitchNear(pos) then
--         this.LoadPointIcon(math.random(1, maxIcon))
--     else
--         local pointView = MapPointView.New(u, v, mapPointId)
--         if pointView then
--             pointView.go.transform:SetParent(Util.GetTransform(this.mapRoot, "uiObj#"))

--             local targetPos = TileMapView.GetLiveTilePos(u, v) * 100
--             -- 完了这玩意还能从天而降
--             if useAnim then
--                 pointView.go:GetComponent("RectTransform").anchoredPosition3D = Vector3.New(targetPos.x, 1000, 0)
--                 pointView.go:GetComponent("RectTransform"):DOAnchorPos(targetPos, 0.5, false):OnComplete(function ()

--                 end)
--             else
--                 pointView.go:GetComponent("RectTransform").anchoredPosition3D = targetPos
--             end
--             pointView:SetPointAnimation(pointView.iconId, 1)
--             pointView.go.transform.localScale = Vector3.one

--             -- 额外尺寸设置
--             if pointView.iconId == MapIconType.ICON_GOLD_BOX or pointView.iconId == MapIconType.ICON_NEW_BOX then
--                 pointView.go.transform.localScale = Vector3.New(1.3, 1.3, 1.3)
--             elseif pointView.iconId == MapIconType.ICON_SUPPLY then
--                 pointView.go.transform.localScale = Vector3.New(0.8, 0.8, 0.8)
--             end


--             pointView:OnShow()
--             pointView:ShowAtkNum(0, false)
--             pointView:ShowFreshTime(false)
--             pointView:ShowDialogue(false)
--             this.iconList[pos] = pointView
--         end
--     end
-- end

-- -- 删除一个图标
-- function this.DeletePointIcon(pos)
--     if this.iconList[pos] then
--         this.iconList[pos]:OnRemovePoint()
--         this.iconList[pos] = nil
--     end
-- end

-- -- 检测当前图标附近是否有图标
-- function this.IsHaveBitchNear(pos)
--     local haveBitch = false
--     local targetU, targetV = Map_Pos2UV(pos)
--     for i, v in pairs(this.iconList) do
--         local u0, v0 = Map_Pos2UV(i)
--         if math.abs(u0 - targetU) + math.abs(v0 - targetV) <= 2 then
--             haveBitch = true
--             break
--         end
--     end

--     -- 检测附近是否是角色
--     if math.abs(this.roleCurPos.u - targetU) + math.abs(this.roleCurPos.v - targetV) <= 1 then
--         haveBitch = true
--     end

--     return haveBitch
-- end

-- -- 震荡波
-- function this.ShakeObjOnce(go, isReverse, func, mid_func)
--     local offSet = isReverse and 90 or 120
--     offSet = offSet / math.min(Screen.width/1080, Screen.height/1920)
--     local originPos = go:GetComponent("RectTransform").anchoredPosition
--     local value = isReverse and -1 or 1
--     local targetPos = originPos + Vector2.New(offSet * m_roleFaceDir.x * value, offSet * m_roleFaceDir.y * value)

--     go:GetComponent("RectTransform"):DOAnchorPos(targetPos, 0.15, false):OnComplete(function ()
--         if mid_func then mid_func() end
--         go:GetComponent("RectTransform"):DOAnchorPos(originPos, 0.15, false):OnComplete(function ()
--             if func then func() end
--         end)
--     end)
-- end


-- -- 获取当前图标的目标值，传入图标的坐标值， 就近原则
-- function this.GetTargetPos(iconPos)
--     local u0, v0 = Map_Pos2UV(iconPos)
--     local posList = {
--         [1] = Vector2.New(u0, v0 - 1),  -- 上
--         [2] = Vector2.New(u0, v0 + 1),  -- 下
--         [3] = Vector2.New(u0 - 1, v0),  -- 左
--         [4] = Vector2.New(u0 + 1, v0),  -- 右
--     }


--     local newList = {}
--     -- 检查合理性
--     local area = monsterArea[m_curMapId]
--     for i = 1, 4 do
--         if posList[i].x >= area.x_pos.min and posList[i].x <= area.x_pos.max
--                 and posList[i].y >= area.y_pos.min and posList[i].y <= area.y_pos.max then
--             local dis = math.abs(this.roleCurPos.u - posList[i].x) + math.abs(this.roleCurPos.v - posList[i].y)
--             local data = {}
--             data.dis = dis
--             data.axis = posList[i]
--             data.index = i
--             newList[#newList + 1] = data
--         end
--     end

--     if #newList > 1 then
--         table.sort(newList, function (a, b)
--             if a.dis == b.dis then
--                 return a.axis.x < b.axis.x
--             else
--                 return a.dis < b.dis
--             end
--         end)
--     end

--     local pos = posList[newList[1].index]
--     return pos
-- end

-- -- 选择一个目标位置， 就近原则
-- function this.SelectTargetPos()
--     local iconList = {}
--     local minDis = 999
--     for i, v in pairs(this.iconList) do
--         local targetU, targetV = Map_Pos2UV(i)
--         -- 计算相对距离
--         local dis = math.abs(this.roleCurPos.u - targetU) + math.abs(this.roleCurPos.v - targetV)
--         minDis = minDis <= dis and minDis or dis
--         local data = {}
--         data.dis = dis
--         data.x_axis = targetU
--         data.pos = i
--         iconList[#iconList + 1] = data
--     end

--     -- 取出目标值. 相等则要x最小的
--     if #iconList > 1 then
--         table.sort(iconList, function (a, b)
--             if a.dis == b.dis then
--                 return a.x_axis < b.x_axis
--             else
--                 return a.dis < b.dis
--             end
--         end )
--     end

--     -- 万一图标还没生出来
--     local targetPos = 0
--     if #iconList > 1 then
--         selectPointPos = iconList[1].pos
--         targetPos = this.GetTargetPos(iconList[1].pos)
--     end
--     return targetPos
-- end

-- ---检查角色与图标的纵深关系
-- function this.IsRoleFront()
--     local v0 = this.roleCurPos.v
--     local u, v = Map_Pos2UV(selectPointPos)
--     return v0 >= v
-- end


-- ---====================================================================

-- -- 角色相关
-- function this.SetRoleDirAction(u, v, isBack)
--     local dU = isBack and this.roleCurPos.u - u or u - this.roleCurPos.u
--     local dV = isBack and this.roleCurPos.v - v or v - this.roleCurPos.v

--     if dU > 0 then
--         this.SetWalkDir(WALK_DIR.RIGHT)
--     elseif dU < 0 then
--         this.SetWalkDir(WALK_DIR.LEFT)
--     elseif dV < 0 then
--         this.SetWalkDir(WALK_DIR.UP)
--     elseif dV > 0 then
--         this.SetWalkDir(WALK_DIR.DOWN)
--     end

-- end

-- function this.SetWalkDir(dir)
--     if not curDir or curDir ~= dir then
--         curDir = dir
--         SkeletonGraphic.transform.localEulerAngles = Vector3.New(0, dir.y, 0)
--         SkeletonGraphic.AnimationState:SetAnimation(0, dir.animation, true)
--     end
-- end

-- -- 角色停止行走时的朝向
-- function this.SetRoleDir(rolePos, iconPos)
--     local u0, v0 = Map_Pos2UV(rolePos)
--     local u, v = Map_Pos2UV(iconPos)
--     if v0 == v then
--         if u0 > u then
--             m_roleFaceDir = Vector2.New(-1, 0)
--             
--             m_faceDir = 3
--         else
--             m_roleFaceDir = Vector2.New(1, 0)
--             
--             m_faceDir = 4
--         end
--     else
--         if v0 > v then
--             m_roleFaceDir = Vector2.New(0, 1)
--             
--             m_faceDir = 1
--         else
--             m_roleFaceDir = Vector2.New(0, -1)
--             
--             m_faceDir = 2
--         end
--     end

-- end


-- function this.PlayerIdle()
--     this.bLeaderIsIdle = true
--     if SkeletonGraphic  and SkeletonGraphic.AnimationState then
--         SkeletonGraphic.AnimationState:SetAnimation(0, "idle", true)
--         SkeletonGraphic.transform.localEulerAngles = Vector3.zero
--     end
--     curDir = nil
-- end

-- function this.PlayerMove()
--     this.bLeaderIsIdle = false
-- end

-- --- =============== 行动中的表现处理 =====================================================

-- -- 设置角色的斗姿
-- function this.SetBattleState(state)
--     this.battleEffect:SetActive(state)
-- end

-- -- 角色行走结束
-- function this.RoleWalkEnd()
--     callList:Clear()
--     this.PlayerIdle()
--     -- 检测方向
--     this.SetRoleDir(this.roleCurPos.u * 256 + this.roleCurPos.v, selectPointPos)
--     -- 设置角色纵深
--     this.SetRoleLayer(this.IsRoleFront())
--     -- 检查一下目标位置是个啥
--     this.AsideTrigger()
-- end

-- -- 检查一下图标类型， 进行战中表现
-- function this.AsideTrigger()
--     local eventPoint = this.iconList[selectPointPos]
--     this.SetIconShow(eventPoint.iconId)
-- end


-- -- 退出战斗状态
-- function this.BattleEnd()
--     this.SetBattleState(false)

--     if not isPanelClose then
--         -- 删点前隐藏那个东西
--         if this.iconList[selectPointPos] then
--             this.iconList[selectPointPos]:ShowDialogue(false)
--         end
--         -- 删除图标
--         this.DeletePointIcon(selectPointPos)
--         local boxState = FightPointPassManager.GetBoxState()
--         boxState = boxState == 0 and 1 or boxState
--         -- 播放特效
--         this.SetEffect(boxState)

--         -- 结束对话
--         iconAction.public_EndDialogue()
--         selectPointPos = 0
--         curDir = nil
--         -- 重置一下
--         this.SetRoleLayer(true)
--     end
-- end

-- -- 进入战斗状态
-- function this.EnterBattle()
--     this.SetBattleState(true)
-- end

-- -- 不是战斗的表现
-- function this.NotBattleShow()
--     this.battleTimer = nil
--     this.targetTimer = nil

--     this.battleTimer = Timer.New(function ()
--         if not isPanelClose then
--             this.BattleEnd()
--             this.targetTimer = Timer.New(function ()
--                 if not isPanelClose then
--                     this.LoadPointIcon(math.random(1, maxIcon), false)
--                     this.SetRoleHitTarget()
--                 end
--             end, 0.5)
--             this.targetTimer:Start()
--             -- 随意一个动画
--             SkeletonGraphic.AnimationState:SetAnimation(0, testAnims[math.random(1, 3)], false)
--         end
--     end, 1)
--     this.battleTimer:Start()
-- end


-- -- 设置遇到图标时的表现
-- function this.SetIconShow(iconType)
--     local point = this.iconList[selectPointPos]

--     if iconType == 8 or iconType == 11 then  -- 宝箱
--         SkeletonGraphic.AnimationState:SetAnimation(0, "jingya", false)
--         iconAction.public_MeGetBaby(iconType, m_faceDir, point, function ()
--             this.NotBattleShow()
--         end)
--     elseif iconType == 7 then                -- NPC, 不一样的BB
--         SkeletonGraphic.AnimationState:SetAnimation(0, "jingya", false)
--         iconAction.public_MeetYourGrandPa(iconType, m_faceDir, point, function ()
--             this.NotBattleShow()
--         end)

--     elseif iconType == 3 then                -- 回血buff
--         SkeletonGraphic.AnimationState:SetAnimation(0, "jingya", false)
--         iconAction.public_EndDialogue()
--         iconAction.public_GiveMeMilk(iconType, point, m_faceDir, selectPointPos, function ()
--             this.NotBattleShow()
--         end)
--     elseif iconType == 14 then                -- 攻击buff
--         SkeletonGraphic.AnimationState:SetAnimation(0, "jingya", false)
--         iconAction.public_GetBuff(iconType, function ()
--             this.NotBattleShow()
--         end)
--     elseif iconType == 15 then                -- 防御buff
--         SkeletonGraphic.AnimationState:SetAnimation(0, "jingya", false)
--         iconAction.public_GetBuff(iconType, function ()
--             this.NotBattleShow()
--         end)

--     else                                     -- 战斗
--     -- 设置战斗状态
--     this.EnterBattle()
--     iconAction.public_EndDialogue()
--         iconAction.public_SetBattleTimes(point, m_roleFaceDir, mapIconConfig[iconType].HurtNum, this.roleCurPos, selectPointPos, function ()
--     hitCallBack()
--     end)

--     end

-- end

-- function this.SetEffect(boxState)
--     local tartPos = boxEffectPos[boxState]

--     this.moneyEffect:GetComponent("RectTransform").anchoredPosition = SetObjPosByUV(selectPointPos)
--     Util.ClearTrailRender(this.moneyEffect)
--     this.SetBoxEffect(false, Vector3.zero)
--     if not FightPointPassManager.isBeginFight then
--         this.moneyEffect:SetActive(true)
--     end
--     this.moneyEffect:GetComponent("RectTransform"):DOAnchorPos(Vector2.New(tartPos.x + 88, tartPos.y + 359), 0.6, false):OnComplete(function ()
--         -- 这些该死的延迟动画
--         if isPanelClose then return end
--         if this.moneyEffect then
--             this.moneyEffect:SetActive(false)
--         end
--         if not FightPointPassManager.isBeginFight then
--             this.SetBoxEffect(true, boxState)
--         end
--     end)
--     SoundManager.PlaySound(SoundConfig.Sound_FightArea_Gold)
-- end

-- -- 设置宝箱特效
-- function this.SetBoxEffect(isShow, state)
--     if not isShow then
--         if this.boxEffect then
--             this.boxEffect:SetActive(false)
--         end
--     else
--         this.boxEffect.transform.localPosition = boxEffectPos[state]
--         this.boxEffect:SetActive(true)
--     end
-- end

-- -- 弹出奖励面板时，如果特效正在飞行，则隐藏特效
-- function this.HideEffect()

-- end



-- --- ====================   角色行走   =====================================
-- function this.OnClickTile(u, v)

--     local v2 = RectTransformUtility.WorldToScreenPoint(TileMapView.GetCamera(), TileMapView.GetLiveTilePos(u, v))
--     v2 = v2 / math.min(Screen.width/1080, Screen.height/1920)


-- end

-- ---设置角色纵深
-- ---@param isFront 设置是否角色在前
-- function this.SetRoleLayer(isFront)
--     local z_axis = isFront and -10 or 10
--     local v3 = this.role.transform.localPosition
--     this.role.transform.localPosition = Vector3(v3.x, v3.y, z_axis)
-- end

-- -- 随机一个位置给大爷走走
-- function this.SetRoleHitTarget()
--     local pos = this.SelectTargetPos()
--     this.SetRoleWalk(pos)
-- end

-- -- 角色在行走
-- function this.OnRoleWalk()
--     iconAction.JudgeBuffState(this.roleCurPos.u, this.roleCurPos.v)
-- end

-- function this.SetRoleWalk(targetPos)
--     local pathList = TileMapView.ShowPath(this.roleCurPos.u, this.roleCurPos.v, targetPos.x, targetPos.y, funcCanPass)
--     -- 不显示那啥，暴露痕迹
--     TileMapView.ClearPath()
--     this.RoleMove(pathList)
-- end

-- function this.RoleMove(pathList)
--     --把最终回调最先入栈
--     callList:Push(function ()
--         this.RoleWalkEnd()
--     end)

--     if not pathList or #pathList == 0 then

--         return
--     end

--     if isPanelClose then
--         return
--     end

--     for i=1, #pathList-1 do --最后的点为起点，不处理
--         local data = pathList[i]
--         local v3 = TileMapView.GetLiveTilePos(data.u, data.v)
--         callList:Push(function ()
--             this.SetRoleDirAction(data.u, data.v)
--             this.roleCurPos = data
--             this.OnRoleWalk()

--             local speed = iconAction.GetRoleSpeed()
--             if not speed or speed <= 0 then
--                 speed = 0.7
--             end
--             this.role.transform:DOLocalMove(Vector3(v3.x, v3.y, v3.z - 10), speed, false):OnStart(function () end):OnUpdate(function() --TODO:测试速度
--                 if isPanelClose then return end
--                 this.PlayStepSound()
--                 local v4 = this.role.transform.localPosition
--                 v4.z = TileMapView.ViewCameraPos.z
--                 TileMapView.SetCameraPos(v4)
--             end):OnComplete(function ()
--                 if isPanelClose then return end
--                 TileMapView.ClearPathTile(data.u, data.v)
--                 this.StackPop()
--             end):SetEase(Ease.Linear)
--         end)
--     end
--     -- 退出第一个栈
--     this.StackPop()
--     this.PlayerMove()
-- end

-- --
-- local _PlayTimeStamp = 0
-- function this.PlayStepSound()
--     local curTimeStamp = GetTimeStamp()
--     if curTimeStamp - _PlayTimeStamp >= 0.3 then
--         _PlayTimeStamp = curTimeStamp

--         SoundManager.PlaySound(SoundConfig.Sound_FootStep..math.random(1,7))
--     end
-- end

-- function this.StackPop()
--     if callList:Count() > 0 then
--         callList:Pop()()
--     end
-- end

-- -- 停止一切该死的行为
-- function this.StopAction()
--     callList:Clear()
--     FightPointPassManager.isBeginFight = true
--     SkeletonGraphic.AnimationState:SetAnimation(0, "idle", true)
--     this.moneyEffect:SetActive(false)
--     this.hitEffect:SetActive(false)
--     iconAction.public_HideEffect()

-- end

-- --- ======================================================================
-- function this.OnGameOver()
--     -- 主动退出时会清除一下，整个游戏退出时会清除所有，此时界面再主动退出时已经销毁了
--     if this.buffEffectRoot then
--         Util.SetParticleScale(this.buffEffectRoot, 0.5)
--     end

--     if this.mapRoot then  -- 避免不是主动退出

--         poolManager:UnLoadAsset(mapCtrl, this.mapRoot, PoolManager.AssetType.GameObject)
--         poolManager:UnLoadAsset(roleRootPath, this.role, PoolManager.AssetType.GameObject)
--         -- poolManager:UnLoadAsset(npc, this.NpcGO, PoolManager.AssetType.GameObject)
--         poolManager:UnLoadAsset(effectPath, this.moneyEffect, PoolManager.AssetType.GameObject)
--         UIManager.camera.clearFlags = CameraClearFlags.Skybox
--         TileMapView.Exit()
--         TileMapController.Exit()
--     end
--     this.mapRoot = nil
--     this.role = nil
--     -- this.NpcGO = nil
--     this.moneyEffect = nil
--     this.buffEffectRoot = nil

--     for i, v in pairs(this.iconList) do
--         if v then
--             v:Dispose()
--             this.iconList[i] = nil
--         end
--     end

-- end

-- function this:OnClose()

-- end

-- function this:Dispose()
--     isPanelClose = true
--     FightPointPassManager.enterFightBattle = false
--     if this.targetTimer then
--         this.targetTimer:Stop()
--     end
--     if this.startTimer then
--         this.startTimer:Stop()
--     end

--     if this.idleTimer then
--         this.idleTimer:Stop()
--     end

--     this.idleTimer = nil
--     this.targetTimer = nil
--     this.startTimer = nil

--     if callList:Count() > 0 then
--         callList:Clear()
--     end

--     iconAction.public_DestroyRegisterComponent()


--     this.OnGameOver()
-- end

-- return this